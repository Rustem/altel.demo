{
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\nlibrary(leaflet)\nlibrary(plyr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\n\n\nbs <- tbl_df(base_stations)\nkpi_output <- arrange(bind_rows(\n  mutate(kpi_2g, technology='2g'),\n  mutate(kpi_3g, technology='3g'),\n  mutate(kpi_lte, technology='lte')\n), year, month, day)\n\nKPIs <- c('fail_rate'='Проц. сбоев, %',\n          'success_call_rate'='Проц. успешных вызовов, %',\n          'cell_avail'='Доступность, %',\n          'max_active_abon'='Макс. кол-во активных абон., ед.',\n          'overload_rate'='Проц. перегрузки, %')\n\nshowBSPopup <- function(map, bsID, lat, lng) {\n  popup <- filter(bs, id == bsID)\n  tech <- switch(popup$technology,\n         '2g'='2G',\n         '3g'='3G',\n         'lte'='LTE')\n  content <- as.character(tagList(\n    tags$p(\"ID: \", substr(popup$id, 1, 10), class='lead'), tags$br(),\n    tags$span(sprintf(\"Модель/Производитель: %s/%s\", popup$model, popup$manufacturer)), tags$br(),\n    tags$span(sprintf(\"Подключенные абоненты: %s\", popup$connAbons * 1000)), tags$br(),\n    tags$span(sprintf(\"Поколение сети: %s\", tech)), tags$br()\n  ))\n  map$showPopup(lat, lng, content, bsID)\n}\n\nmap2Color <- function(statuses) {\n  mapper <- function(status) {\n    return(switch(status,\n           ok='#33FF66',\n           normal='#FFFF00',\n           bad='#FF0000'))\n  }\n  return(unlist(Map(mapper, statuses)))\n}\n\nshinyServer(function(input, output, session) {\n\n  map <- createLeafletMap(session, \"map\")\n    \n  baseStationsInBounds <- reactive({\n    if (is.null(input$map_bounds))\n      return(cities[FALSE,])\n    bounds <- input$map_bounds\n    latRng <- range(bounds$north, bounds$south)\n    lngRng <- range(bounds$east, bounds$west)\n    \n    rv <- filter(bs,\n           lat >= latRng[1] & lat <= latRng[2],\n           lon >= lngRng[1] & lon <= lngRng[2])\n    rv\n  })\n  \n  baseStations <- reactive({\n    rv <- baseStationsInBounds()\n    if(!is.null(input$tech)) {\n      rv <- filter(rv, technology %in% input$tech)\n    } else {\n      rv <- filter(rv, FALSE)  \n    }\n    if(!is.null(input$status)) {\n      chosenColors <- map2Color(input$status)\n      rv <- filter(rv, color %in% chosenColors)\n    } else {\n      rv <- filter(rv, FALSE)\n    }\n  })\n  \n  output$summary <- renderTable({\n    curBS <- baseStations()\n    if(!any('color' %in% colnames(curBS)))\n      return()\n    by_status <- summarise(group_by(curBS, color), count=n())\n    alive_bs <- summarise(filter(by_status, color == '#FFFF00' | color == '#33FF66'), count=sum(count))\n    all_bs <- summarise(by_status, count=sum(count))\n    if(all_bs$count != 0)\n      cell_avail <- round(alive_bs$count / all_bs$count * 100, 1)\n    else\n      cell_avail <- 0\n    data.frame('Доступность сети'=paste(cell_avail, '%', sep=''),\n               'Подключ абоненты'=summarise(curBS, count=sum(connAbons))$count)\n  })\n  \n  chunksize <- 10\n  # session$onFlushed is necessary to work around a bug in the Shiny/Leaflet\n  # integration; without it, the addCircle commands arrive in the browser\n  # before the map is created.\n  session$onFlushed(once=TRUE, function() {\n    paintObjs <- observe({\n      curBS <- baseStations()\n      # Clear existing circles before drawing\n      map$clearMarkers()\n      if(nrow(curBS) == 0) {\n        return()\n      }\n      for (from in seq.int(1, nrow(curBS), chunksize)) {\n        to <- min(nrow(curBS), from + chunksize)\n        curChunk <- curBS[from:to,]\n        try(\n          map$addCircleMarker(\n            curChunk$lat, curChunk$lon, 10,\n            curChunk$id,\n            list(stroke=FALSE, fill=TRUE),\n            list(color=curBS$color[from:to])\n          )\n        )\n      }\n    })\n    \n    # TIL this is necessary in order to prevent the observer from\n    # attempting to write to the websocket after the session is gone.\n    session$onSessionEnded(paintObjs$suspend)\n  })\n  \n  # set map view on a city\n  observe({\n    city_det <- filter(cities, city == input$city)\n    if(is.null(city_det))\n      return()\n    map$setView(city_det$lat, city_det$lon, city_det$zoom)\n  })\n  \n  clickObj <- observe({\n    event <- input$map_marker_click\n    if(is.null(event))\n      return()\n    map$clearPopups()\n    isolate({\n      showBSPopup(map, event$id, event$lat, event$lng)\n  #    map$fitBounds(event$lat - 0.5, event$lon - 0.5, event$lat + 0.5, event$lon + 0.5)\n    })\n  })\n  session$onSessionEnded(clickObj$suspend)\n  \n  observe({\n    stillSelected <- isolate(input$input.cities[input$input.cities %in% city_list])\n    updateSelectInput(session, 'input.cities', choices=city_list,\n                      selected=stillSelected)\n  })\n  \n  observe({\n    stillSelected <- isolate(input$input.tech[input$input.tech %in% c('2g', '3g', 'lte')])\n    updateSelectInput(session, 'input.tech', choices=c('2G'='2g', '3G'='3g', 'LTE'='lte'),\n                      selected=stillSelected)\n  })\n  \n  dtRange <- reactive({\n    if(is.null(input$input.dtRange)) {\n      return()\n    }\n    from_dt <- as.integer(unlist(strsplit(strftime(input$input.dtRange[1], '%Y-%m-%d'), '-')))\n    to_dt <- as.integer(unlist(strsplit(strftime(input$input.dtRange[2], '%Y-%m-%d'), '-')))\n    rbind(data.frame(year=from_dt[1], month=from_dt[2], day=from_dt[3]),\n      data.frame(year=to_dt[1], month=to_dt[2], day=to_dt[3]))\n  })\n  \n  observe({\n    if(is.null(input$goto)) {\n      return()\n    }\n    isolate({\n      map$clearPopups()\n      targetId <- input$goto$id\n      rv <- filter(bs, id == targetId)\n      dist <- 0.5\n      showBSPopup(map, rv$id, rv$lat, rv$lon)\n      map$fitBounds(rv$lat - dist, rv$lon - dist, rv$lat + dist, rv$lon + dist)\n    })\n  })\n  targetBSId <- reactive({\n    if(is.null(input$gotoKPI)) {\n      return()\n    }\n    input$gotoKPI$id\n  })\n  tbl <- reactive({\n    bsIds <- filter(bs, is.null(input$input.cities) | city %in% input$input.cities)\n    targetId <- targetBSId()\n    if(!is.null(targetId)) {\n      bsIds <- bsIds[bsIds$id == targetId]\n    }\n    \n    rawIds <- bsIds$id\n    tbl_output <- kpi_output %>%\n      filter(id %in% rawIds) %>%\n      filter(is.null(input$input.tech) | technology %in% input$input.tech) %>%\n      mutate(date = strftime(ISOdate(year, month, day), '%d/%m/%y'))\n    \n    if(!is.null(dtRange())) {\n      dtRng <- dtRange()\n      fromDt <- dtRng[1,]\n      toDt <- dtRng[2,]\n      \n      tbl_output <- filter(tbl_output,\n                           ((year > fromDt$year) | (year == fromDt$year & month > fromDt$month) | (year == fromDt$year & month == fromDt$month & day >= fromDt$day)) &\n                             ((year < toDt$year) | (year == toDt$year & month < toDt$month) | (year == toDt$year & month == toDt$month & day <= toDt$day)))\n    }\n    tbl_output <- tbl_output[c('id', 'date', input$colvis)]\n    tbl_output\n  })\n  output$`kpi_tbl` <- renderDataTable({\n    tbl_output <- tbl()\n    tbl_output <- tbl_output %>%\n      mutate(Action = paste('<a class=\"go-map\" href=\"\" data-id=\"', id, '\">Карта</a>', sep=\"\"))\n    tbl_output <- plyr::rename(tbl_output,\n                               replace=c('date'='Дата', 'fail_rate'='Проц. сбоев', 'success_call_rate'='Проц. успешных вызовов', 'cell_avail'='Доступность', 'max_active_abon'='Макс. кол-во активных абон.','overload_rate'='Проц. перегрузки'),\n                               warn_missing=FALSE)\n    tbl_output\n  }, escape=FALSE)\n  \n  output$downloadData <- downloadHandler(\n    filename = function() {\n      paste('report-', Sys.Date(), '.csv', sep='')\n    },\n    content = function(file) {\n      tbl_output <- tbl()\n      tbl_output <- plyr::rename(tbl_output,\n                                 replace=c('date'='Дата', 'fail_rate'='Проц. сбоев', 'success_call_rate'='Проц. успешных вызовов', 'cell_avail'='Доступность', 'max_active_abon'='Макс. кол-во активных абон.','overload_rate'='Проц. перегрузки'),\n                                 warn_missing=FALSE)\n      write.csv(tbl_output, file)\n    }\n  )\n  \n  output$plots <- renderUI({\n    if(is.null(input$colvis)) {\n      return()\n    }\n    dtRng <- dtRange()\n    plot_list <- lapply(1:length(input$colvis), function(i) {\n      plotname <- paste('plot_', input$colvis[i], sep='')\n      column(6, plotOutput(plotname, height=280, width=300))\n    })\n    fluidRow(do.call(tagList, plot_list))\n  })\n  observe({\n    if(is.null(input$colvis)) {\n      return()\n    }\n    max_plots <- length(input$colvis)\n    by_day = group_by(tbl(), date)\n    plot_data <- summarise_each(by_day,\n              funs(mean), -date, -id)\n    colors <- brewer.pal(max_plots, \"Spectral\")\n    for(i in 1:max_plots) {\n      local({\n        local_i <- i\n        plotname <- paste('plot_', input$colvis[i], sep='')\n        plot_date <- plot_data[c('date', input$colvis[local_i])]\n        xrange <- range(plot_date$date)\n        yrange <- range(plot_date[[input$colvis[local_i]]])\n        output[[plotname]] <- renderPlot({\n          p <- ggplot(plot_data, aes_string(x='date', y=input$colvis[local_i]))\n          p + geom_line(colour=colors[local_i], size=1, aes(group=1)) +\n              scale_x_discrete(labels = abbreviate) + \n              xlab('Дата (по дням)') +\n              ylab(KPIs[input$colvis[local_i]])\n        })\n      })\n    }\n  })\n})\n\n\n",
    "created" : 1430213923733.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3249222321",
    "id" : "2770C7C1",
    "lastKnownWriteTime" : 1430367247,
    "path" : "~/work/projects/r/shiny/altel.demo/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}